<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Es6 Function on Daily note</title>
    <link>https://daily.whidy.net/categories/es6-function/</link>
    <description>Recent content in Es6 Function on Daily note</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 06 Feb 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://daily.whidy.net/categories/es6-function/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>ECMAScript6入门</title>
      <link>https://daily.whidy.net/posts/2018-02-06-es6-function/</link>
      <pubDate>Tue, 06 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://daily.whidy.net/posts/2018-02-06-es6-function/</guid>
      <description>2018年2月6日 晴 一般
 ECMAScript6入门 今天肚子不舒服状态不佳, 粗略的把第6.数值的扩展看完了. 感觉就是Math相关方法太多了, 我肯定记不住了.大概留点印象吧.
函数的扩展 然后接着看7.函数的扩展
参数默认值的位置  只有函数的尾参数可以省略 javascript function f(x, y = 5, z) { return [x, y, z]; } f() // [undefined, 5, undefined] f(1) // [1, 5, undefined] f(1, ,2) // 报错 f(1, undefined, 2) // [1, 5, 2]  如果传入undefined，将触发该参数等于默认值，null则没有这个效果。 函数也是有length属性的, 但是有个特点, 它依次计算至有参数默认值为止, 加入第一个就有参数, 那长度以然是0. javascript (function (a) {}).length // 1 (function (a = 5) {}).length // 0 (function (a, b, c = 5) {}).</description>
    </item>
    
    <item>
      <title>ECMAScript6入门/函数</title>
      <link>https://daily.whidy.net/posts/2018-01-29-es6-function/</link>
      <pubDate>Mon, 29 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://daily.whidy.net/posts/2018-01-29-es6-function/</guid>
      <description>2018年1月29日 阴有小雨 一般
 ECMAScript6入门 / 函数 ECMAScript6入门 我再次阅读字符串的扩展这部分, 老实说, 这一节关于charCodeAt, charAt, codePointAt, fromCodePoint, at, normalize这些东西感到枯燥的很, 我还不能理解这些内容在实际应用上的广泛性.
函数(Function)  关于函数得知识点, 我才发现我欠缺的多得多. 以下是我对函数了解较少或者需要注意的几个点得总结.
 作用域和函数堆栈 递归 例如，思考一下如下的函数定义：
var foo = function bar() { // statements go here };  在这个函数体内，以下的语句是等价的：
 bar() arguments.callee() foo()  获取树结构中所有的节点时，使用递归实现要容易得多：
function walkTree(node) { if (node == null) // return; // do something with node for (var i = 0; i &amp;lt; node.childNodes.length; i++) { walkTree(node.</description>
    </item>
    
  </channel>
</rss>