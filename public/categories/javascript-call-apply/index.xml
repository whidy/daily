<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Javascript Call Apply on Daily note</title>
    <link>https://daily.whidy.net/categories/javascript-call-apply/</link>
    <description>Recent content in Javascript Call Apply on Daily note</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 08 Feb 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://daily.whidy.net/categories/javascript-call-apply/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>call和apply</title>
      <link>https://daily.whidy.net/posts/2018-02-08-object-call-apply/</link>
      <pubDate>Thu, 08 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://daily.whidy.net/posts/2018-02-08-object-call-apply/</guid>
      <description>2018年2月8日 晴 一般
 函数原型和继承学习总结  昨晚回去又看了一下JavaScript权威指南第六章, 其中提到, 1, &amp;quot;test&amp;quot;, true, 这类不是对象, 或者也可以当作临时对象, 书中举例var s = &amp;quot;test&amp;quot;, 此时可以给s一个属性, 比如s.a = 1, 但是你访问不到该属性s.a是undefined. 因为这三种是原始类型什么的- -.
另外还有个包装对象, 好像目前看不出来有啥用. 先不看了吧- -
今天接着看昨天没看完的内容和补充昨天的内容.
 昨日内容补充 Object.prototype.constructor  早上读昨天没看完的文章Basic Inheritance with JavaScript Constructors
 一般的通过new构造函数实现继承就不说了. 这里用call来实现(用面向对象表达)所谓的&amp;rdquo;一个通过SuperHero类创建的marvel实例, 继承SuperHuman的方法&amp;rdquo;的过程. 下面是合并后的代码:
function SuperHuman(name, superPower) { this.name = name; this.superPower = superPower; } SuperHuman.prototype.usePower = function() { console.log(this.superPower + &#39;!&#39;); }; var banshee = new SuperHuman(&#39;Silver Banshee&#39;, &#39;sonic wail&#39;); function SuperHero(name, superPower) { // Reuse SuperHuman initialization SuperHuman.</description>
    </item>
    
  </channel>
</rss>