---
layout: post
title: "复习正则表达式"
date: 2018-02-01
categories: regexp
---
> 2018年2月1日 晴 无聊

# 复习正则表达式

> 昨天感觉不在状态, 边看正则边打酱油, 所以没有什么好写的, 今天总结一下.
>
> 正好ES6也有正则方面的内容, 看看有什么新特性, 顺便又把`精通正则表达式`拿出来粗看了前面几章节, 于是给自己出了几道题.

## 题一: 找出符合规则的时间

匹配符合标准格式的时间. 这是内容部分:

```text
now is 09:4 am test
now isx9:4 am test
now isx2:54 am test
now isA09:04 amwtest
now is_12:30 pm adsadadasda
now is 21:59 amdsadasdwq
now is 22:75 am_dsad21
now is 41:60 pm   dsadsad 
now is 26:23 am   dwadwq
now is 2a:23 am   dwadwq
```

期望结果(虽然24小时制后面存在[ap]m感觉还是不太合理.)

```text
09:4 am
9:4 am
2:54 am
09:04 am
12:30 pm
21:59 am
```

看起来应该不是很复杂. 结果我写了一天没写出来. 因为我不知道怎么剔除`26`. 似乎无论怎么写, 在`2`和`6`之间正向断言始终都会匹配到`6`. ES5却是不支持后行断言(negative lookbehind)的, 据说ES6支持[后行断言](http://es6.ruanyifeng.com/?search=%E8%A7%A3%E6%9E%84&x=10&y=8#docs/regex#%E5%90%8E%E8%A1%8C%E6%96%AD%E8%A8%80)了, 才得以解决这个问题, 然而不通过后行断言来处理这个问题, 我始终没有写出来, 难道真的是**实现不了**?

这是一个未能完美解决的其中一种写法.

```javascript
/([01]\d|(?=2(?![4-9]))2\d?|(?!2)\d):(0?(?=\d)[0-9]|[1-5][0-9])(\s*[a|p]m)/gim
```

这是通过后行断言的写法: 

```javascript
/([01]\d:|(?=2(?![4-9]))2\d?:|(?<!2)\d:)(0?(?=\d)[0-9]|[1-5][0-9])(\s*[a|p]m)/gim
```

## 题二: 找出文件后缀名

再来看另一个, 获取文件后缀名的正则写法问题:

可能有以下文件, 需要准确获取每个文件的文件类型, 例如:

```text
a.jpg
hello world.png
c.c.mp3
_do_(it)._unknow
```

期望:

```text
.jpg
.png
.mp3
._unknow
```

这个其实还算按比较简单的了. 不过在我复习正则之前硬是想不起来咋写, 稍微过了一遍再写就容易多了. 正则写法`\..(?!\.).*`.

改题目来源于前几天同事发的一个javascript自验网站: [ScriptOJ](https://scriptoj.com/)首页的题目.

## 其他疑惑小结

> 虽然看起来大部分正则相关的规则我已经基本掌握, 也能写出一些简单的匹配了, 不过还是有几个不太常用的内容比较迷惑, 故专门抽出来研究.

### `[\b]`和`\b`和`\B`

#### `[\b]` - 退格符

另外其实我一直都搞不清楚`[\b]`匹配一个`退格(U+0008)`是什么鬼. 似乎没有人告诉我这个退格符长什么样. 我也不知道那些各种转载各种规则的人他们自己知不知道是啥... (难道就我不知道- -)

找了半天, 总算在[MSDN: 正则表达式语言 - 快速参考](https://msdn.microsoft.com/zh-cn/library/az24scfc%28v=vs.110%29.aspx#Anchor_0)找到了示例. 难道就是匹配`\b`用的吗😂, 当然很明显的区别是, 它属于`字符转义`

#### `\b` - 一个词的边界

> MSDN: **匹配必须出现在 \w（字母数字）和 \W（非字母数字）字符之间的边界上。**

这个就很好理解了, 会写先行断言的我当然是知道了, 他不占用任何位置, 边界一般都是单词或数字两边, 更为具体的通过[MDN的正则表达式](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions)文档`\b`介绍内的**注意**有指引, 查到ecma文档的15.10.2.6 [Assertion](http://www.ecma-international.org/ecma-262/5.1/#sec-15.10.2.6)中`IsWordChar`处, 不过由于个人能力有限, 对其理解如下:

通过这段代码([正则表达式案例分析 （一） - (3) 单词边界](https://gitee.com/janking/Infinite-f2e/issues/IDWPH)):

```javascript
"I'd prefer p2p O_O".replace(/\b/g,function(){
  console.log(arguments)
});
```

输出结果:

```javascript
{ '0': '', '1': 0, '2': 'I\'d prefer p2p O_O' }
{ '0': '', '1': 1, '2': 'I\'d prefer p2p O_O' }
{ '0': '', '1': 2, '2': 'I\'d prefer p2p O_O' }
{ '0': '', '1': 3, '2': 'I\'d prefer p2p O_O' }
{ '0': '', '1': 4, '2': 'I\'d prefer p2p O_O' }
{ '0': '', '1': 10, '2': 'I\'d prefer p2p O_O' }
{ '0': '', '1': 11, '2': 'I\'d prefer p2p O_O' }
{ '0': '', '1': 14, '2': 'I\'d prefer p2p O_O' }
{ '0': '', '1': 15, '2': 'I\'d prefer p2p O_O' }
{ '0': '', '1': 18, '2': 'I\'d prefer p2p O_O' }
```

我们看到被断掉(用`|`表示)的位置分别是:

|I|'|d| |prefer| |p2p| |O_O|

0 1 2 3 4      1011  1415  18

![]()

也就是说连续的`单词`和`数字`和`_`组合(上文提到的ecma部分的表格也对应了这个)都是一个单位, 他的两侧就是截断. 除此之外的任何符号都会截断他们.

另外, 在MSDN文档中, 它被归为`定位点`.

#### `\B` - 一个非单词边界

前面说了这么多, `\B`的理解就很轻松了, 一个非单词边界. 就不多说了, 看看MSDN的例子就清楚了.

模式: `\Bend\w*\b`

原字符串: `end sends endure lender`

匹配结果: `ends`和`ender`

### 关于正则个人的经验

> 其实搞正则匹配, 我个人的从精通正则表达式书中阅读后的感受就是, 匹配一定要一个个看, 慢慢的看, 比如上面这个例子, 我看看模式先是`\B`, 然后再找原字符串, 依次步骤分析:
>
> 1. 第一个`e`左边(位置)是边界不符合, **失败**看下一个字符
> 1. 第二个`n`左边(位置)符合`\B`, 匹配成功, 再看模式`\B`后面的`e`
> 1. 模式`\B`(位置)后面的`e`不匹配`n`, **失败**再看下一个字符`d`
> 1. 第三个`d`左边(位置)符合`\B`, 匹配成功, 再看模式`\B`后面的`e`
> 1. 模式`\B`(位置)后面的`e`不匹配第三个字母`d`, **失败**再看下一个字符<code> </code>(这里是个空格啦😂)
> 1. ...(此处省略, 一直到`send`单词)
> 1. (前面都不符合,当遇到了`send`), 经过一步步后移, 模式`\B`(位置)走到了`s`右侧, **成功**! 此刻, 兴奋的将模式移到第二个`e`
> 1. 好巧, 模式中的`e`匹配到`s`后面的字符`e`, 再回到模式下一位`n`
> 1. 世界太小了, 又一次成功了, 紧接着是`d`, 看起来一一对应上了
> 1. ...(截至目前, `\Bend`部分已经和`sends`中的`end`配上了, 可是还没完呢)
> 1. 模式`d`后面是`\w*`, 我们回到原字符串部分`send`后面是`s`所以也**成功**了
> 1. 再看模式部分`\w*`下一位`\b`, 碰到上面讲的单词边界了( •̀ ω •́ )y, 我们看看原字符串部分`sends `这里的确被截断了, 因此原字符串开始新一轮匹配
> 1. ...(反复如上步骤)
>
> 最后就得出了匹配结果的两组字符串了. 不知道我这样讲大家能不能理解, 或者说这种思路大家有没有疑问和反对之处, 如果有希望大家留言😁
